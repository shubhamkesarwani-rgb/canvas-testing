# -*- coding: utf-8 -*-
"""Rule Processor V3 Script.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jDVhPaFONTC1KwJSNPzxuWf_PWNvYSNx
"""

# Full final script (v7) for Google Colab
# Logic:
# - New session per prompt
# - If agent returns {"action":"user_input"} ‚Üí resend JSON as prompt
# - Otherwise ‚Üí treat response as final and store AS-IS in CSV
# - No tool call handling
# - No hint handling
'''
import os
import re
import csv
import json
import requests
import traceback
from typing import Optional, Tuple, Any, List
from google.colab import files

# ============================
# CONFIGURATION
# ============================
BASE_URL = "https://common-mgmt-ragaai-canvas.deephealthos.com"
PROJECT_ID = "a6a0c68d60274ef8"
AGENT_ID = "1821de7f906442b3"

AUTHORIZATION_TOKEN = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkByYWdhIiwib3JnUHVibGljSWQiOiI4NGVmMjI4NDQwYWM3OWFiIiwib3JnTmFtZSI6IlJhZ2EiLCJvcmdEb21haW4iOiJyYWdhIiwib3JnUm9sZSI6Ik9XTkVSIiwicm9sZXMiOltdLCJ1c2VyRnVsbE5hbWUiOiJSYWdhIEFkbWluIiwidXNlclB1YmxpY0lkIjoiODJhOWMyN2Y1MGM0YjlkOCIsInVzZXJOYW1lIjoiYWRtaW5AcmFnYSIsImV4cCI6MTc2OTQ4MjM1OCwiaWF0IjoxNzY5Mzk1OTU4LCJqdGkiOiI4MmE5YzI3ZjUwYzRiOWQ4In0.7E08zLtJsPh3LzXQg44L2WwN41_PToWOoNXlPVFEwM4HsQXniNiOgvCKicm5f8DbSCn3oIx82oftE7UFaNgA7w"
USER_ID = "user_82a9c27f50c4b9d8"
APP_NAME = "rule_processor_agent_refactored_rule_version_a957"

HEADERS = {
    "accept": "*/*",
    "authorization": f"Bearer {AUTHORIZATION_TOKEN}",
    "content-type": "application/json",
    "origin": BASE_URL,
    "user-agent": "Mozilla/5.0"
}

# ============================
# HELPERS
# ============================

def strip_code_fence(text: str) -> str:
    if not text:
        return text
    fences = re.findall(r"```(?:json)?\n([\s\S]*?)\n```", text)
    return fences[0].strip() if fences else text.strip()

def find_json_in_text(text: str) -> Optional[Any]:
    if not text:
        return None
    text = strip_code_fence(text)
    try:
        return json.loads(text)
    except Exception:
        pass
    matches = re.findall(r'(\{[\s\S]*?\})', text)
    for m in sorted(matches, key=len, reverse=True):
        try:
            return json.loads(m)
        except Exception:
            continue
    return None

def is_user_input_action(obj: Any) -> bool:
    return (
        isinstance(obj, dict)
        and obj.get("action") == "user_input"
        and isinstance(obj.get("response"), list)
    )

# ============================
# NEW HELPER (ADDED)
# ============================

def enrich_user_input_action(obj: Any) -> Any:
    """
    Enrich user_input actions:
      - cptCode -> append "72030" (string) if values empty
      - others  -> append 67030 (numeric) if values empty
    """
    if not is_user_input_action(obj):
        return obj

    for item in obj.get("response", []):
        if not isinstance(item, dict):
            continue

        values = item.get("values")
        entity = item.get("entity")

        if isinstance(values, list) and len(values) == 0:
            if entity == "cptCode":
                values.append("72030")   # STRING
            else:
                values.append(67030)     # NUMBER

    return obj

# ============================
# API CALLS
# ============================

def create_session() -> Optional[str]:
    url = f"{BASE_URL}/api/projects/{PROJECT_ID}/agents/{AGENT_ID}/sessions"
    r = requests.post(url, headers=HEADERS, json={}, timeout=30)
    r.raise_for_status()
    data = r.json()
    return data.get("sessionId") or data.get("id") or data.get("data", {}).get("sessionId")

def run_agent_sse(session_id: str, prompt: str) -> Tuple[Optional[Any], Optional[str]]:
    url = f"{BASE_URL}/api/projects/{PROJECT_ID}/agents/{AGENT_ID}/run_sse"
    payload = {
        "appName": APP_NAME,
        "userId": USER_ID,
        "sessionId": session_id,
        "newMessage": {
            "role": "user",
            "parts": [{"text": prompt}]
        }
    }

    headers = HEADERS.copy()
    headers["accept"] = "text/event-stream"

    collected_texts = []

    with requests.post(url, headers=headers, json=payload, stream=True, timeout=120) as resp:
        resp.raise_for_status()
        for line in resp.iter_lines(decode_unicode=True):
            if not line or "data:" not in line:
                continue
            data = line.replace("data:", "").strip()
            print("RAW SSE LINE:", line)
            if data == "[DONE]":
                continue
            try:
                chunk = json.loads(data)
            except Exception:
                continue
            print("PARSED SSE CHUNK:", json.dumps(chunk, indent=2))
            if isinstance(chunk, dict):
                for k in ("text", "content", "message", "finalResponse", "result"):
                    val = chunk.get(k)
                    if isinstance(val, str):
                        collected_texts.append(val)
                    elif isinstance(val, dict):
                        parts = val.get("parts", [])
                        for p in parts:
                            if isinstance(p, dict) and "text" in p:
                                collected_texts.append(p["text"])

    raw_text = collected_texts[-1] if collected_texts else None
    parsed_json = find_json_in_text(raw_text) if raw_text else None
    return parsed_json, raw_text

# ============================
# CORE LOOP
# ============================

def process_prompt(prompt: str, max_loops: int = 20) -> Tuple[str, str]:
    session_id = create_session()
    print(f"  ‚úÖ Session created: {session_id}")

    current_prompt = prompt

    for i in range(max_loops):
        print(f"  üîÅ Iteration {i+1}")
        parsed_json, raw_text = run_agent_sse(session_id, current_prompt)

        # CASE A ‚Üí user_input ‚Üí enrich & resend
        if is_user_input_action(parsed_json):
            print("  üîÅ action=user_input ‚Üí enriching & resending to agent")

            enriched = enrich_user_input_action(parsed_json)

            print("  üì¶ Enriched user_input JSON:")
            print(json.dumps(enriched, indent=2))

            current_prompt = json.dumps(enriched, ensure_ascii=False)
            continue

        # CASE B ‚Üí FINAL
        print("  ‚úÖ Final response received")
        final_response = raw_text or json.dumps(parsed_json, ensure_ascii=False)
        return final_response, "PASS"

    return "Max iterations reached", "FAIL"

# ============================
# CSV PROCESSING
# ============================

def process_csv(input_file: str, output_file: str):
    with open(input_file, encoding="utf-8") as f:
        rows = list(csv.DictReader(f))

    prompt_col = next(c for c in rows[0] if c.lower() in ("prompt", "prompts", "input"))

    results = []

    for idx, row in enumerate(rows, 1):
        prompt = row.get(prompt_col, "").strip()
        if not prompt:
            continue

        print(f"\n[{idx}] Processing prompt")
        response, status = process_prompt(prompt)

        results.append({
            "prompts": prompt,
            "response": response,
            "status": status
        })

    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=["prompts", "response", "status"])
        writer.writeheader()
        writer.writerows(results)

    files.download(output_file)

# ============================
# MAIN
# ============================

print("üöÄ RagaAI Catalyst - FINAL user_input Loop Version")
print("=" * 60)

input_file = "/content/clean_prompts_single_column.csv"
output_file = "prompt_results.csv"

if not os.path.isfile(input_file):
    uploaded = files.upload()
    input_file = next(iter(uploaded))

process_csv(input_file, output_file)
print("\n‚úÖ Done.")
'''

# Full final script (v7) for Google Colab
# Logic:
# - New session per prompt
# - If agent returns {"action":"user_input"} ‚Üí resend JSON as prompt
# - Otherwise ‚Üí treat response as final and store AS-IS in CSV
# - No tool call handling
# - No hint handling

import os
import re
import csv
import json
import requests
import traceback
from typing import Optional, Tuple, Any, List

# ============================
# CONFIGURATION
# ============================
BASE_URL = "https://common-mgmt-ragaai-canvas.deephealthos.com"
PROJECT_ID = "a6a0c68d60274ef8"
AGENT_ID = "1821de7f906442b3"

AUTHORIZATION_TOKEN = "eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbkByYWdhIiwib3JnUHVibGljSWQiOiI4NGVmMjI4NDQwYWM3OWFiIiwib3JnTmFtZSI6IlJhZ2EiLCJvcmdEb21haW4iOiJyYWdhIiwib3JnUm9sZSI6Ik9XTkVSIiwicm9sZXMiOltdLCJ1c2VyRnVsbE5hbWUiOiJSYWdhIEFkbWluIiwidXNlclB1YmxpY0lkIjoiODJhOWMyN2Y1MGM0YjlkOCIsInVzZXJOYW1lIjoiYWRtaW5AcmFnYSIsImV4cCI6MTc2OTY2MzYxOSwiaWF0IjoxNzY5NTc3MjE5LCJqdGkiOiI4MmE5YzI3ZjUwYzRiOWQ4In0.7RHczyen0NlYmuizaCffjIVXVAK36Ht1Y_i95DnZXyGulFTWZVtVQ-kVXKRxGKDo4eIRsGar74txJkNq8hssuQ"
USER_ID = "user_82a9c27f50c4b9d8"
APP_NAME = "rule_processor_agent_refactored_rule_version_a957"

HEADERS = {
    "accept": "*/*",
    "authorization": f"Bearer {AUTHORIZATION_TOKEN}",
    "content-type": "application/json",
    "origin": BASE_URL,
    "user-agent": "Mozilla/5.0"
}

# ============================
# HELPERS
# ============================

def strip_code_fence(text: str) -> str:
    if not text:
        return text
    fences = re.findall(r"```(?:json)?\n([\s\S]*?)\n```", text)
    return fences[0].strip() if fences else text.strip()

def find_json_in_text(text: str) -> Optional[Any]:
    if not text:
        return None
    text = strip_code_fence(text)
    try:
        return json.loads(text)
    except Exception:
        pass
    matches = re.findall(r'(\{[\s\S]*?\})', text)
    for m in sorted(matches, key=len, reverse=True):
        try:
            return json.loads(m)
        except Exception:
            continue
    return None

def is_user_input_action(obj: Any) -> bool:
    return (
        isinstance(obj, dict)
        and obj.get("action") == "user_input"
        and isinstance(obj.get("response"), list)
    )

# ============================
# NEW HELPER (ADDED)
# ============================

def enrich_user_input_action(obj: Any) -> Any:
    """
    Enrich user_input actions:
      - cptCode -> append "72030" (string) if values empty
      - others  -> append 67030 (numeric) if values empty
    """
    if not is_user_input_action(obj):
        return obj

    for item in obj.get("response", []):
        if not isinstance(item, dict):
            continue

        values = item.get("values")
        entity = item.get("entity")

        if isinstance(values, list) and len(values) == 0:
            if entity == "cptCode":
                values.append("72030")   # STRING
            else:
                values.append(67030)     # NUMBER

    return obj

# ============================
# API CALLS
# ============================

def create_session() -> Optional[str]:
    url = f"{BASE_URL}/api/projects/{PROJECT_ID}/agents/{AGENT_ID}/sessions"
    r = requests.post(url, headers=HEADERS, json={}, timeout=30)
    r.raise_for_status()
    data = r.json()
    return data.get("sessionId") or data.get("id") or data.get("data", {}).get("sessionId")

def run_agent_sse(session_id: str, prompt: str) -> Tuple[Optional[Any], Optional[str]]:
    url = f"{BASE_URL}/api/projects/{PROJECT_ID}/agents/{AGENT_ID}/run_sse"
    payload = {
        "appName": APP_NAME,
        "userId": USER_ID,
        "sessionId": session_id,
        "newMessage": {
            "role": "user",
            "parts": [{"text": prompt}]
        }
    }

    headers = HEADERS.copy()
    headers["accept"] = "text/event-stream"

    collected_texts = []

    with requests.post(url, headers=headers, json=payload, stream=True, timeout=120) as resp:
        resp.raise_for_status()
        for line in resp.iter_lines(decode_unicode=True):
            if not line or "data:" not in line:
                continue
            data = line.replace("data:", "").strip()
            print("RAW SSE LINE:", line)
            if data == "[DONE]":
                continue
            try:
                chunk = json.loads(data)
            except Exception:
                continue
            print("PARSED SSE CHUNK:", json.dumps(chunk, indent=2))
            if isinstance(chunk, dict):
                for k in ("text", "content", "message", "finalResponse", "result"):
                    val = chunk.get(k)
                    if isinstance(val, str):
                        collected_texts.append(val)
                    elif isinstance(val, dict):
                        parts = val.get("parts", [])
                        for p in parts:
                            if isinstance(p, dict) and "text" in p:
                                collected_texts.append(p["text"])

    raw_text = collected_texts[-1] if collected_texts else None
    parsed_json = find_json_in_text(raw_text) if raw_text else None
    return parsed_json, raw_text

# ============================
# CORE LOOP
# ============================

def process_prompt(prompt: str, max_loops: int = 20) -> Tuple[str, str, str]:
    session_id = create_session()
    print(f"  ‚úÖ Session created: {session_id}")

    current_prompt = prompt

    for i in range(max_loops):
        print(f"  üîÅ Iteration {i+1}")
        parsed_json, raw_text = run_agent_sse(session_id, current_prompt)

        # CASE A ‚Üí user_input ‚Üí enrich & resend
        if is_user_input_action(parsed_json):
            print("  üîÅ action=user_input ‚Üí enriching & resending to agent")

            enriched = enrich_user_input_action(parsed_json)

            print("  üì¶ Enriched user_input JSON:")
            print(json.dumps(enriched, indent=2))

            current_prompt = json.dumps(enriched, ensure_ascii=False)
            continue

        # CASE B ‚Üí FINAL
        print("  ‚úÖ Final response received")
        final_response = raw_text or json.dumps(parsed_json, ensure_ascii=False)
        return final_response, "PASS", session_id

    return "Max iterations reached", "FAIL", session_id

# ============================
# CSV PROCESSING WITH LIVE LOGGING
# ============================

def process_csv_live(input_file: str, output_file: str, max_prompts: Optional[int] = None):
    """
    Process prompts from CSV file and write results incrementally.
    
    Args:
        input_file: Path to input CSV file
        output_file: Path to output CSV file
        max_prompts: Maximum number of prompts to process. If None, process all prompts.
    """
    with open(input_file, encoding="utf-8") as f:
        rows = list(csv.DictReader(f))

    prompt_col = next(c for c in rows[0] if c.lower() in ("prompt", "prompts", "input"))

    # Open the output file in append mode, write header if file doesn't exist
    file_exists = os.path.isfile(output_file)
    with open(output_file, "a", newline="", encoding="utf-8") as f_out:
        writer = csv.DictWriter(f_out, fieldnames=["prompts", "response", "status", "session_id"])
        if not file_exists:
            writer.writeheader()

        prompts_processed = 0
        for idx, row in enumerate(rows, 1):
            prompt = row.get(prompt_col, "").strip()
            if not prompt:
                continue

            print(f"\n[{idx}] Processing prompt")
            response, status, session_id = process_prompt(prompt)

            writer.writerow({
                "prompts": prompt,
                "response": response,
                "status": status,
                "session_id": session_id
            })
            f_out.flush()  # ensure it's written immediately

            print(f"  ‚úÖ Prompt logged to {output_file} with session_id={session_id}")
            
            prompts_processed += 1
            if max_prompts is not None and prompts_processed >= max_prompts:
                print(f"\n‚ö†Ô∏è  Reached maximum limit of {max_prompts} prompts. Exiting loop.")
                break

# ============================
# MAIN
# ============================

if __name__ == "__main__":
    print("üöÄ RagaAI Catalyst - FINAL user_input Loop Version")
    print("=" * 60)

    input_file = "100prompts_for_automation.csv"
    output_file = "prompt_results.csv"

    # Configure maximum number of prompts to process (set to None to process all)
    MAX_PROMPTS_TO_PROCESS = 10  # Change this value to limit prompts, or set to None for unlimited
    '''
    if not os.path.isfile(input_file):
        uploaded = files.upload()
        input_file = next(iter(uploaded))
    '''

    process_csv_live(input_file, output_file, max_prompts=MAX_PROMPTS_TO_PROCESS)
    print(f"\n‚úÖ Done. Progress logged to {output_file}")